<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>PoolGame – Physics Edition</title>
    <link rel="stylesheet" href="style.css">

    <!-- Three.js, examples + Cannon‑ES via modern import‑map -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://threejs.org/build/three.module.js",
          "three/addons/": "https://threejs.org/examples/jsm/",
          "cannon-es": "https://cdn.skypack.dev/cannon-es"
        }
      }
    </script>

    <style>
      body { margin:0; overflow:hidden; }
      canvas { display:block; }
      #powerHud {
        position:fixed; bottom:24px; left:50%; transform:translateX(-50%);
        width:200px; height:12px; background:#555; border-radius:6px;
        overflow:hidden; pointer-events:none;
      }
      #powerHud>div {
        height:100%; width:0%; background:#0f0;
      }
    </style>

    <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import * as CANNON from 'cannon-es';

    /* ---------------------------------------------------------
       THREE BASICS
    --------------------------------------------------------- */
    const scene    = new THREE.Scene();
    scene.background = new THREE.Color(0xaaaaaa);

    const camera   = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    /* ---------------------------------------------------------
       POINTER‑LOCK (FPS) CONTROLS
    --------------------------------------------------------- */
    const controls = new PointerLockControls(camera, document.body);
    document.addEventListener('click', () => controls.lock());

    /* ---------------------------------------------------------
       PHYSICS WORLD (Cannon‑ES)
    --------------------------------------------------------- */
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
    world.broadphase  = new CANNON.SAPBroadphase(world);
    world.allowSleep  = true;
    world.solver.iterations = 15;

    // Materials & contact
    const feltMat  = new CANNON.Material('felt');
    const ballMat  = new CANNON.Material('ball');
    const railMat  = new CANNON.Material('rail');

    world.addContactMaterial(new CANNON.ContactMaterial(ballMat, ballMat, {
        friction: 0.05,
        restitution: 0.95
    }));
    world.addContactMaterial(new CANNON.ContactMaterial(ballMat, feltMat, {
        friction: 0.25,
        restitution: 0.93
    }));
    world.addContactMaterial(new CANNON.ContactMaterial(ballMat, railMat, {
        friction: 0.1,
        restitution: 0.92
    }));

    /* ---------------------------------------------------------
       LIGHTS
    --------------------------------------------------------- */
    const spot = new THREE.SpotLight(0xffffff, 100);
    spot.position.set(0, 10, 0);
    spot.castShadow = true;
    scene.add(spot);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    /* ---------------------------------------------------------
       WORLD HELPERS
    --------------------------------------------------------- */
    const physicsObjects = []; //  { mesh, body }
    let   cueBody = null;      //  reference to white ball physics body
    const obstacles = [];
    const initialBallStates = [];

    /* ---------------------------------------------------------
       TABLE + CUSHIONS + STATIC BODIES
    --------------------------------------------------------- */
    addTable(0, 0);

    function addTable(x, z) {
      const tableGroup = new THREE.Group();
      tableGroup.position.set(x, 0, z);

      // ----- felt (mesh) -----
      const tableGeom   = new THREE.BoxGeometry(10, 0.2, 5);
      const tableMat    = new THREE.MeshStandardMaterial({ color: 0x006600, roughness:0.4 });
      const tableMesh   = new THREE.Mesh(tableGeom, tableMat);
      tableMesh.position.set(0, 0.8, 0);
      tableMesh.receiveShadow = true;
      tableGroup.add(tableMesh);

      // ----- felt (physics plane) -----
      const feltBody = new CANNON.Body({ mass:0, material:feltMat });
      feltBody.addShape(new CANNON.Plane());
      feltBody.position.set(x, 0.9, z);               // top surface
      feltBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
      world.addBody(feltBody);

      // ----- legs ----- (visual only)
      const legGeom = new THREE.CylinderGeometry(0.1, 0.1, 0.75, 16);
      const legMat  = new THREE.MeshStandardMaterial({ color: 0x552200 });
      [[-4.5,0.375,-2],[4.5,0.375,-2],[-4.5,0.375,2],[4.5,0.375,2]].forEach(([lx,ly,lz])=>{
          const m=new THREE.Mesh(legGeom,legMat); m.position.set(lx,ly,lz); m.castShadow=true; tableGroup.add(m);
      });

      // ----- cushions (visual + physics) -----
      const cushionHeight     = 0.2;
      const cushionThickness  = 0.3;
      const cushionMatVisual  = new THREE.MeshStandardMaterial({ color: 0x333333, roughness:0.5 });

      // long rails (east/west)
      [{z:  2.5 + cushionThickness/2}, {z: -2.5 - cushionThickness/2}].forEach(({z:zz})=>{
        const cush = new THREE.Mesh(new THREE.BoxGeometry(10, cushionHeight, cushionThickness), cushionMatVisual);
        cush.position.set(0, 0.9 + cushionHeight/2, zz);
        cush.receiveShadow = true;
        tableGroup.add(cush);

        const body = new CANNON.Body({ mass:0, material:railMat });
        body.addShape(new CANNON.Box(new CANNON.Vec3(5, cushionHeight/2, cushionThickness/2)));
        body.position.set(x, 0.9 + cushionHeight/2, z + zz);
        world.addBody(body);
      });

      // short rails (north/south)
      [{x: -5 - cushionThickness/2},{x: 5 + cushionThickness/2}].forEach(({x:xx})=>{
        const cush = new THREE.Mesh(new THREE.BoxGeometry(cushionThickness, cushionHeight, 5 + 2*cushionThickness), cushionMatVisual);
        cush.position.set(xx, 0.9 + cushionHeight/2, 0);
        cush.receiveShadow = true;
        tableGroup.add(cush);

        const body = new CANNON.Body({ mass:0, material:railMat });
        body.addShape(new CANNON.Box(new CANNON.Vec3(cushionThickness/2, cushionHeight/2, (5+2*cushionThickness)/2)));
        body.position.set(x + xx, 0.9 + cushionHeight/2, z);
        world.addBody(body);
      });

      scene.add(tableGroup);
      obstacles.push({ minX:x-5.5, maxX:x+5.5, minZ:z-2.8, maxZ:z+2.8 });
    }

    /* ---------------------------------------------------------
       GROUND & ROOM (visual only)
    --------------------------------------------------------- */
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(50,50), new THREE.MeshStandardMaterial({ color:0x888888 }));
    ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

    // Simple walls (visual)
    addWall(30, 5, 5, 6, 0);   // right
    addWall(20,-9,-5, 6, 90);  // far
    addWall(30, 6,-15,6, 0);   // left
    addWall(20,20,-5, 6, 90);  // bar
    addWall(10, 9, 0, 1, 90);  // small divider

    function addWall(size, x, z, height, orientation){
      const thickness = 0.5;                          // depth of the wall box
      const wallMesh  = new THREE.Mesh(
        new THREE.BoxGeometry(size, height, thickness),
        new THREE.MeshStandardMaterial({ color: 0x552200 })
      );
      wallMesh.position.set(x, height / 2, z);
      if (orientation === 90) wallMesh.rotation.y = Math.PI / 2;
      wallMesh.receiveShadow = true;
      scene.add(wallMesh);

      /* ---------- physics body so the BALLS bounce off ---------- */
      const body = new CANNON.Body({ mass: 0, material: railMat });
      if (orientation === 90){                         // north–south wall
        body.addShape(new CANNON.Box(
          new CANNON.Vec3(thickness / 2, height / 2, size / 2)
        ));
        body.quaternion.setFromEuler(0, Math.PI / 2, 0);
      } else {                                         // east–west wall
        body.addShape(new CANNON.Box(
          new CANNON.Vec3(size / 2, height / 2, thickness / 2)
        ));
      }
      body.position.set(x, height / 2, z);
      world.addBody(body);

      /* ---------- AABB so the PLAYER camera can’t walk through ---------- */
      obstacles.push({
        minX: x - (orientation === 90 ? thickness / 2 : size / 2),
        maxX: x + (orientation === 90 ? thickness / 2 : size / 2),
        minZ: z - (orientation === 90 ? size / 2 : thickness / 2),
        maxZ: z + (orientation === 90 ? size / 2 : thickness / 2)
      });
    }


    /* ---------------------------------------------------------
       BALLS (mesh + physics) –  First one is cue ball
    --------------------------------------------------------- */
    //addBall(0xffffff, 0, 1, 0);      // cue
    //addBall(0xf0ff00, 0.5, 1, 0.4);
    //addBall(0x000000, 1, 1, 1);
    //addBall(0x0000ff, 2, 1, 1);
    //addBall(0x00ff00, 3, 1, 1);

    function addBall(color,x,y,z){
      const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.1,32,32), new THREE.MeshStandardMaterial({ color, roughness:0.2 }));
      mesh.castShadow = true; mesh.position.set(x,y,z); scene.add(mesh);

      const body = new CANNON.Body({ mass: 0.17, shape: new CANNON.Sphere(0.1), material: ballMat });
      body.position.set(x,y,z);
      body.linearDamping = 0.2;   // stops after rolling
      world.addBody(body);

      physicsObjects.push({ mesh, body });
      initialBallStates.push({ body, mesh, pos: new THREE.Vector3(x, y, z) });
      if(color === 0xffffff && !cueBody) cueBody = body;
    }

    const ballColors = [          // quick palette, 15 distinct tints
      0xff0000, 0xffff00, 0x0000ff, 0x00ff00, 0xff8800,
      0x5500ff, 0xff00ff, 0x000000, 0xcc2222, 0xcccc00,
      0x2222cc, 0x22cc22, 0xffaa55, 0x8855ff, 0xff55ff
    ];

    (function placeInitialRack(){
      const r   = 0.1, gap = 0.005;
      const d   = 2*r + gap;               // centre-to-centre spacing
      const apexX =  3.5;                  // triangle sits near +X cushion
      let colIdx = 0;

      for(let row=0; row<5; row++){        // 5-4-3-2-1 = 15 balls
        for(let n=0; n<5-row; n++){
          const x = apexX + row*d;
          const z = (-(5-row-1)/2 + n) * d;
          addBall(ballColors[colIdx++], x, 1, z);
        }
      }

      // white cue ball at the other end of the table
      addBall(0xffffff, -4, 1, 0);
    })();

    /* ---------------------------------------------------------
       CAMERA START & MOVEMENT
    --------------------------------------------------------- */
    camera.position.set(-8,2,0);
    const keys = { w:false, a:false, s:false, d:false };
    const speed = 0.1;
    let velocityY = 0;
    const gravityPlayer = -0.02;
    const groundLevel   = 2;

    window.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.key)) keys[e.key]=true; });
    window.addEventListener('keyup',   e => { if(keys.hasOwnProperty(e.key)) keys[e.key]=false; });
    window.addEventListener('keydown', e => { if(e.code==='Space' && camera.position.y<=groundLevel) velocityY=0.3; });
    window.addEventListener('keydown', e=>{
      if(e.code === 'KeyR'){
        initialBallStates.forEach(s=>{
          s.body.position.set(s.pos.x, s.pos.y, s.pos.z);
          s.body.velocity.set(0,0,0);
          s.body.angularVelocity.set(0,0,0);
          s.body.quaternion.set(0,0,0,1);
          s.mesh.position.copy(s.pos);
          s.mesh.quaternion.set(0,0,0,1);
        });
      }
    });

    function updateCameraPosition(){
      if(!controls.isLocked) return;
      const prevX = camera.position.x, prevZ = camera.position.z;
      const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y=0; dir.normalize();
      const right = new THREE.Vector3(); right.crossVectors(camera.up, dir).normalize();
      if(keys.w) camera.position.addScaledVector(dir,  speed);
      if(keys.s) camera.position.addScaledVector(dir, -speed);
      if(keys.a) camera.position.addScaledVector(right,  speed);
      if(keys.d) camera.position.addScaledVector(right, -speed);
      velocityY += gravityPlayer; camera.position.y += velocityY;
      if(camera.position.y<=groundLevel){ camera.position.y=groundLevel; velocityY=0; }
      obstacles.forEach(o=>{
        const pad = 0.3; // player “radius”
        if(camera.position.x > o.minX - pad && camera.position.x < o.maxX + pad &&
          camera.position.z > o.minZ - pad && camera.position.z < o.maxZ + pad){
            camera.position.x = prevX;
            camera.position.z = prevZ;
        }
      });
    }

    /* ---------------------------------------------------------
       CUE ACTION –  Hold right‑mouse to build power, release to strike
    --------------------------------------------------------- */
    const hud = document.createElement('div'); hud.id='powerHud'; hud.innerHTML='<div></div>'; document.body.appendChild(hud);
    const bar = hud.firstElementChild;

    let powerStart = null;
    window.addEventListener('contextmenu', e => e.preventDefault()); // disable menu

    window.addEventListener('mousedown', e => {
      if(e.button===2 && controls.isLocked){ // right button
        powerStart = performance.now();
      }
    });
    window.addEventListener('mouseup', e => {
      if(e.button===2 && powerStart!==null && cueBody){
        const duration = (performance.now() - powerStart) / 1000; // seconds
        const power    = Math.min(duration, 1.5);                 // cap at 1.5 s
        const aimDir   = new THREE.Vector3(); camera.getWorldDirection(aimDir); aimDir.y = 0; aimDir.normalize();
        const impulse  = new CANNON.Vec3(aimDir.x * power * 4, 0, aimDir.z * power * 4);
        cueBody.applyImpulse(impulse, cueBody.position);
        powerStart = null; bar.style.width = '0%';
      }
    });

    // Power HUD update
    function updateHud(){
      if(powerStart!==null){
        const pct = Math.min((performance.now()-powerStart)/1500,1)*100;
        bar.style.width = pct+'%';
      }
    }

    /* ---------------------------------------------------------
       RENDER / PHYSICS LOOP
    --------------------------------------------------------- */
    const fixedTimeStep = 1/120; // 120 Hz
    let   lastTime;
    function animate(time){
      requestAnimationFrame(animate);
      if(lastTime!==undefined){
        world.step(fixedTimeStep, (time-lastTime)/1000);
      }
      physicsObjects.forEach(o=>{
        o.mesh.position.copy(o.body.position);
        o.mesh.quaternion.set(o.body.quaternion.x, o.body.quaternion.y, o.body.quaternion.z, o.body.quaternion.w);
      });
      updateCameraPosition();
      updateHud();
      renderer.render(scene, camera);
      lastTime = time;
    }
    animate();

    /* ---------------------------------------------------------
       RESIZE
    --------------------------------------------------------- */
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    </script>
</head>
<body>
</body>
</html>

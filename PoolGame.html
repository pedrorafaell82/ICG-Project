<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>PoolGame</title>
    <link rel="stylesheet" href="style.css">

    <script type="importmap">
        {
          "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
          }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Configuração básica da cena
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Adicionar controle de cursor bloqueado
        const controls = new PointerLockControls(camera, document.body);

        // Evento para ativar o controle ao clicar na tela
        document.addEventListener('click', () => {
            controls.lock();
        });

        let velocityY = 0;        // Velocidade vertical
        const gravity = -0.02;    // Gravidade aplicada ao jogador
        const jumpStrength = 0.3; // Força do salto
        const groundLevel = 2;    // Altura fixa do solo

        // Iluminação
        const luz = new THREE.SpotLight(0xffffff, 200);
        luz.position.set(0, 10, 0);
        luz.castShadow = true;
        scene.add(luz);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        // Fundo da cena
        scene.background = new THREE.Color(0xaaaaaa);

        // Chão
        const geometryChao = new THREE.PlaneGeometry(50, 50);
        const materialChao = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8 });
        const chao = new THREE.Mesh(geometryChao, materialChao);
        chao.rotation.x = -Math.PI / 2;
        chao.receiveShadow = true;
        scene.add(chao);

        // Mesa
        addTable(0, 0)

        // Bolas
        addBall(0xffffff, 0, 1, 0);
        addBall(0xf0ff00, 0.5, 1, 0.4);
        addBall(0x000000, 1, 1, 1)
        addBall(0x0000ff, 2, 1, 1)
        addBall(0x00ff00, 3, 1, 1)

        //Paredes
        addWall(30, 5, 5, 6, 0); //Parede Direita
        addWall(20, -9, -5, 6, 90); //Parede Fundo
        addWall(30, 6, -15, 6, 0); //Parede Esquerda
        addWall(20, 20, -5, 6, 90); //Parede Bar
        addWall(10, 9, 0, 1, 90); //Mini Parede


        // Definir posição inicial da câmara
        camera.position.set(0, 2, 5);

        // Configuração para movimento FPS
        const keys = { w: false, a: false, s: false, d: false };
        const speed = 0.1;

        document.addEventListener('keydown', (event) => {
            if (keys.hasOwnProperty(event.key.toLowerCase())) {
                keys[event.key.toLowerCase()] = true;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (keys.hasOwnProperty(event.key.toLowerCase())) {
                keys[event.key.toLowerCase()] = false;
            }
        });

        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && camera.position.y <= groundLevel) {
                velocityY = jumpStrength;
            }
        });

        function addTable(x, z) {
            const tableGroup = new THREE.Group();

            // Criar mesa
            const geometryTable = new THREE.BoxGeometry(10, 0.2, 5);
            const materialTable = new THREE.MeshStandardMaterial({ color: 0x006600, roughness: 0.4, metalness: 0.1 });
            const table = new THREE.Mesh(geometryTable, materialTable);
            table.position.set(0, 0.8, 0);
            table.receiveShadow = true;
            tableGroup.add(table);

            // Criar pernas da mesa
            const geometryPerna = new THREE.CylinderGeometry(0.1, 0.1, 0.75, 16);
            const materialPerna = new THREE.MeshStandardMaterial({ color: 0x552200 });

            const posicoesPernas = [
                [-4.5, 0.375, -2], [4.5, 0.375, -2],
                [-4.5, 0.375, 2], [4.5, 0.375, 2]
            ];

            posicoesPernas.forEach(pos => {
                const perna = new THREE.Mesh(geometryPerna, materialPerna);
                perna.castShadow = true;
                perna.position.set(pos[0], pos[1], pos[2]);
                tableGroup.add(perna);
            });

            // Definir posição do grupo
            tableGroup.position.set(x, 0, z);
            
            // Adicionar à cena
            scene.add(tableGroup);
        }

        function addWall(size, x, z, height, orientation) {
            // Criar geometria da parede
            const wallGeometry = new THREE.BoxGeometry(size, height, 0.5); // Largura definida por 'size', altura fixa em 3, espessura 0.5
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x552200, roughness: 0.6 });

            // Criar a parede
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(x, height/2, z); // Mantém a altura fixa no solo
            wall.receiveShadow = true;

            // Aplicar rotação se for perpendicular (90 graus)
            if (orientation == 90) {
                wall.rotation.y = Math.PI / 2; // Rotaciona a parede para ficar perpendicular
            }

            // Adicionar à cena
            scene.add(wall);
        }

        function addBall(color, x, y, z) {
            const geometryBola = new THREE.SphereGeometry(0.1, 32, 32);
            const materialBola = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0 });
            const bola = new THREE.Mesh(geometryBola, materialBola);
            bola.castShadow = true;
            bola.position.set(x, y, z);
            scene.add(bola);
        }

        function updateCameraPosition() {
            if (controls.isLocked) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(camera.up, direction).normalize();

                if (keys.w) camera.position.addScaledVector(direction, speed);
                if (keys.s) camera.position.addScaledVector(direction, -speed);
                if (keys.d) camera.position.addScaledVector(right, -speed);
                if (keys.a) camera.position.addScaledVector(right, speed);

                velocityY += gravity;
                camera.position.y += velocityY;

                if (camera.position.y <= groundLevel) {
                    camera.position.y = groundLevel;
                    velocityY = 0;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateCameraPosition();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</head>
<body>
    <div id="Tag3DScene"></div>
</body>
</html>
